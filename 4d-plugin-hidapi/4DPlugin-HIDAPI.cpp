/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-HIDAPI.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : HIDAPI
 #	author : miyako
 #	2020/02/27
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-HIDAPI.h"

#pragma mark -

std::mutex globalMutex;

std::map<uint32_t, hid_device *> __hid_devices;

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin :
            case kServerInitPlugin :
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr) OnStartup, NULL);
                break;
                
            case kDeinitPlugin :
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr) OnExit, NULL);
                break;
                
			// --- HIDAPI
                
            case 1 :
                hid_enumerate(params);
                break;
            case 2 :
                hid_open(params);
                break;
            case 3 :
                hid_open_path(params);
                break;
            case 4 :
                hid_close(params);
                break;
            case 5 :
                hid_write(params);
                break;
            case 6 :
                hid_read(params);
                break;
            case 7 :
                hid_send_feature_report(params);
                break;
            case 8 :
                hid_get_feature_report(params);
                break;
            case 9 :
                hid_set_nonblocking(params);
                break;
                
        }

	}
	catch(...)
	{

	}
}

#pragma mark -

bool is_libhidusb_ready = false;

void OnStartup() {
    
    is_libhidusb_ready = (0 == hid_init());
    
}

void OnExit() {
    
    if(is_libhidusb_ready) {
        hid_exit();
        __hid_devices.clear();
    }

}

#pragma mark -

void hid_enumerate(PA_PluginParameters params) {
    
    PA_CollectionRef devices = PA_CreateCollection();
    
    if(is_libhidusb_ready) {
        
        hid_device_info *info = hid_enumerate(0, 0);
        
        if(info) {
            
            while (info) {
                
                PA_CollectionRef device = PA_CreateObject();

                ob_set_s(device, L"path", info->path);
                ob_set_n(device, L"vendor_id", info->vendor_id);
                ob_set_n(device, L"product_id", info->product_id);
                ob_set_a(device, L"serial_number", info->serial_number);
                ob_set_n(device, L"release_number", info->release_number);
                ob_set_a(device, L"manufacturer_string", info->manufacturer_string);
                ob_set_a(device, L"product_string", info->product_string);
                ob_set_n(device, L"usage_page", info->usage_page);
                ob_set_n(device, L"usage", info->usage);
                ob_set_n(device, L"interface_number", info->interface_number);
                
                PA_Variable v = PA_CreateVariable(eVK_Object);
                PA_SetObjectVariable(&v, device);
                PA_SetCollectionElement(devices, PA_GetCollectionLength(devices), v);
                PA_ClearVariable(&v);
                
                info = info->next;
            }
            
            hid_free_enumeration(info);
        }
    }
    
    PA_ReturnCollection(params, devices);
    
}

void hid_open(PA_PluginParameters params) {

    PA_ObjectRef returnValue = PA_CreateObject();
    
    ob_set_b(returnValue, L"success", false);
    
    if(is_libhidusb_ready) {
        
        PackagePtr pParams = (PackagePtr)params->fParameters;
        
        C_LONGINT Param1;
        C_LONGINT Param2;
        C_TEXT Param3;

        Param1.fromParamAtIndex(pParams, 1);
        Param2.fromParamAtIndex(pParams, 2);
        Param3.fromParamAtIndex(pParams, 3);
        
        unsigned short vendor_id = Param1.getIntValue();
        unsigned short product_id = Param2.getIntValue();
                
        const wchar_t *serial_number = NULL;
        size_t len = Param3.getUTF16Length();
        
        std::vector<char> buf((len+1) * sizeof(wchar_t));
        
        if(len) {
            
            #if VERSIONWIN
                    serial_number = Param3.getUTF16StringPtr();
            #else
                    CFStringRef str = CFStringCreateWithBytes(kCFAllocatorDefault,
                                                              (const UInt8 *)Param3.getUTF16StringPtr(),
                                                              sizeof(PA_Unichar) * Param3.getUTF16Length(),
                                                              kCFStringEncodingUTF16LE,
                                                              true);
                    if(str){
                                                
                        if(CFStringGetCString(str,
                                              &buf[0],
                                              buf.size(),
                                              kCFStringEncodingUTF32)){
                            serial_number = (const wchar_t *)&buf[0];
                        }
                        CFRelease(str);
                    }
            #endif
        }

        hid_device *device = hid_open(vendor_id,
                                      product_id,
                                      serial_number);
        
        if(device) {
            
            std::lock_guard<std::mutex> lock(globalMutex);
            
            unsigned int i = 1;
            
            while (__hid_devices.find(i) != __hid_devices.end()) {
                i++;
            }
            
            __hid_devices.insert(std::map<uint32_t, hid_device*>::value_type(i, device));
         
            ob_set_n(returnValue, L"device", i);
            ob_set_b(returnValue, L"success", true);
            
            std::vector<wchar_t>buf(STRING_BUFFER_LENGTH + 1);
            
            if(0 == hid_get_manufacturer_string(device, &buf[0], STRING_BUFFER_LENGTH)) {
                ob_set_a(returnValue, L"manufacturer_string", (const wchar_t *)&buf[0]);
            }
            
            memset(&buf[0], 0, sizeof(wchar_t) * buf.size());
            
            if(0 == hid_get_product_string(device, &buf[0], STRING_BUFFER_LENGTH)) {
                ob_set_a(returnValue, L"product_string", (const wchar_t *)&buf[0]);
            }
            
            memset(&buf[0], 0, sizeof(wchar_t) * buf.size());
            
            if(0 == hid_get_serial_number_string(device, &buf[0], STRING_BUFFER_LENGTH)) {
                ob_set_a(returnValue, L"serial_number_string", (const wchar_t *)&buf[0]);
            }
            
        }
    }
    
    PA_ReturnObject(params, returnValue);
}

void hid_open_path(PA_PluginParameters params) {

    PA_ObjectRef returnValue = PA_CreateObject();
    
    ob_set_b(returnValue, L"success", false);
    
    if(is_libhidusb_ready) {
        
        PackagePtr pParams = (PackagePtr)params->fParameters;
        
        C_TEXT Param1;

        Param1.fromParamAtIndex(pParams, 1);
                
        CUTF8String _path;

        Param1.copyUTF8String(&_path);
        
        const char *path = (const char *)_path.c_str();
    
        hid_device *device = hid_open_path(path);
        
        if(device) {
            
            std::lock_guard<std::mutex> lock(globalMutex);
            
            unsigned int i = 1;
            
            while (__hid_devices.find(i) != __hid_devices.end()) {
                i++;
            }
            
            __hid_devices.insert(std::map<uint32_t, hid_device*>::value_type(i, device));
         
            ob_set_n(returnValue, L"device", i);
            ob_set_b(returnValue, L"success", true);
            
            std::vector<wchar_t>buf(STRING_BUFFER_LENGTH + 1);
            
            if(0 == hid_get_manufacturer_string(device, &buf[0], STRING_BUFFER_LENGTH)) {
                ob_set_a(returnValue, L"manufacturer_string", (const wchar_t *)&buf[0]);
            }
            
            memset(&buf[0], 0, sizeof(wchar_t) * buf.size());
            
            if(0 == hid_get_product_string(device, &buf[0], STRING_BUFFER_LENGTH)) {
                ob_set_a(returnValue, L"product_string", (const wchar_t *)&buf[0]);
            }
            
            memset(&buf[0], 0, sizeof(wchar_t) * buf.size());
            
            if(0 == hid_get_serial_number_string(device, &buf[0], STRING_BUFFER_LENGTH)) {
                ob_set_a(returnValue, L"serial_number_string", (const wchar_t *)&buf[0]);
            }
            
            /*
            
            int string_index = 0;
            
            memset(&buf[0], 0, sizeof(wchar_t) * buf.size());
            
            PA_CollectionRef indexed_string = PA_CreateCollection();
            
            PA_Unichar *indexed_string_value = NULL;
            
            std::wstring wstr;
            
            while (0 == hid_get_indexed_string(device, string_index, &buf[0], STRING_BUFFER_LENGTH)) {
                
                string_index++;
                
                wstr = std::wstring((const wchar_t *)&buf[0], wcslen((const wchar_t *)&buf[0]));
                
                #if VERSIONWIN
                        indexed_string_value = wstr.c_str();
                #else
                        
                        CFStringRef str = CFStringCreateWithBytes(kCFAllocatorDefault,
                                                                  (const UInt8 *)wstr.c_str(),
                                                                  sizeof(wchar_t) * wstr.length(),
                                                                  kCFStringEncodingUTF32,
                                                                  true);
                        if(str){
                            
                            std::vector<PA_Unichar>_buf(wstr.length() + 1);
                                                    
                            if(CFStringGetCString(str,
                                                  (char *)&_buf[0],
                                                  sizeof(PA_Unichar) * _buf.size(),
                                                  kCFStringEncodingUTF16LE)){
                                indexed_string_value = (PA_Unichar *)&buf[0];
                            }
                            
                            CFRelease(str);
                        }
                #endif
                
                PA_Variable v = PA_CreateVariable(eVK_Unistring);
                PA_Unistring u = PA_CreateUnistring(indexed_string_value);
                PA_SetStringVariable(&v, &u);
                
                PA_SetCollectionElement(indexed_string, PA_GetCollectionLength(indexed_string), v);

                PA_DisposeUnistring(&u);
                PA_ClearVariable(&v);
                
                memset(&buf[0], 0, sizeof(wchar_t) * buf.size());
                
            }
            ob_set_c(returnValue, L"indexed_string", indexed_string);
            */
        }
        
    }
    
    PA_ReturnObject(params, returnValue);
}

void hid_close(PA_PluginParameters params) {

    if(is_libhidusb_ready) {

        PackagePtr pParams = (PackagePtr)params->fParameters;
        
        C_LONGINT Param1;

        Param1.fromParamAtIndex(pParams, 1);
        
        std::lock_guard<std::mutex> lock(globalMutex);
        
        hid_device *device = NULL;
        
        std::map<uint32_t, hid_device*>::iterator pos = __hid_devices.find(Param1.getIntValue());
        
        if(pos != __hid_devices.end()) {
            device = pos->second;
            
            hid_close(device);
        }
 
    }
    
}

void hid_write(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_LONGINT Param1;
    C_BLOB Param2;
    
    PA_ObjectRef returnValue = PA_CreateObject();
    
    ob_set_b(returnValue, L"success", false);
    
    if(is_libhidusb_ready) {

        Param1.fromParamAtIndex(pParams, 1);
        Param2.fromParamAtIndex(pParams, 2);

        std::lock_guard<std::mutex> lock(globalMutex);
        
        hid_device *device = NULL;
        
        std::map<uint32_t, hid_device*>::iterator pos = __hid_devices.find(Param1.getIntValue());
        
        if(pos != __hid_devices.end()) {

            device = pos->second;

            unsigned char *data = (unsigned char *)Param2.getBytesPtr();
            size_t length = Param2.getBytesLength();
            int status = 0;
            
            status = hid_write(device,
                               data,
                               length);
            
            ob_set_b(returnValue, L"success", 0 == status);
            
            if(0 != status) {
                
                ob_set_a(returnValue, L"error", hid_error(device));
                
            }
                        
        }
        
    }
        
    PA_ReturnObject(params, returnValue);
}

void hid_read(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_LONGINT Param1;
    C_BLOB Param2;
    C_LONGINT Param3;
    
    PA_ObjectRef returnValue = PA_CreateObject();
    
    ob_set_b(returnValue, L"success", false);
    
    if(is_libhidusb_ready) {

        Param1.fromParamAtIndex(pParams, 1);
        Param2.fromParamAtIndex(pParams, 2);
        Param3.fromParamAtIndex(pParams, 3);

        std::lock_guard<std::mutex> lock(globalMutex);
        
        hid_device *device = NULL;
        
        std::map<uint32_t, hid_device*>::iterator pos = __hid_devices.find(Param1.getIntValue());
        
        if(pos != __hid_devices.end()) {

            device = pos->second;

            size_t length = Param2.getBytesLength();
            int milliseconds = Param3.getIntValue();
            int status = 0;
            
            std::vector<char>buf(length);
            
            unsigned char *data = (unsigned char *)&buf[0];
            
            if(Param3.getIntValue() == 0) {
                status = hid_read(device,
                                  data,
                                  length);
            }else{
                status = hid_read_timeout(device,
                                          data,
                                          length,
                                          milliseconds);
            }
            
            ob_set_b(returnValue, L"success", 0 == status);
            
            if(0 != status) {
                
                ob_set_a(returnValue, L"error", hid_error(device));
                
            }
            
            Param2.setBytes((const uint8_t *)data, (unsigned int)length);
            
        }
        
    }
    
    Param2.toParamAtIndex(pParams, 2);
    
    PA_ReturnObject(params, returnValue);
}

void hid_send_feature_report(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_LONGINT Param1;
    C_BLOB Param2;
    
    PA_ObjectRef returnValue = PA_CreateObject();
    
    ob_set_b(returnValue, L"success", false);
    
    if(is_libhidusb_ready) {

        Param1.fromParamAtIndex(pParams, 1);
        Param2.fromParamAtIndex(pParams, 2);

        std::lock_guard<std::mutex> lock(globalMutex);
        
        hid_device *device = NULL;
        
        std::map<uint32_t, hid_device*>::iterator pos = __hid_devices.find(Param1.getIntValue());
        
        if(pos != __hid_devices.end()) {

            device = pos->second;

            unsigned char *data = (unsigned char *)Param2.getBytesPtr();
            size_t length = Param2.getBytesLength();
            int status = 0;
            
            status = hid_send_feature_report(device,
                                             data,
                                             length);
            
            ob_set_b(returnValue, L"success", 0 == status);
            
            if(0 != status) {
                
                ob_set_a(returnValue, L"error", hid_error(device));
                
            }
                        
        }
        
    }
        
    PA_ReturnObject(params, returnValue);
}

void hid_get_feature_report(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_LONGINT Param1;
    C_BLOB Param2;
    
    PA_ObjectRef returnValue = PA_CreateObject();
    
    ob_set_b(returnValue, L"success", false);
    
    if(is_libhidusb_ready) {

        Param1.fromParamAtIndex(pParams, 1);
        Param2.fromParamAtIndex(pParams, 2);

        std::lock_guard<std::mutex> lock(globalMutex);
        
        hid_device *device = NULL;
        
        std::map<uint32_t, hid_device*>::iterator pos = __hid_devices.find(Param1.getIntValue());
        
        if(pos != __hid_devices.end()) {

            device = pos->second;

            size_t length = Param2.getBytesLength();
            int status = 0;
            
            std::vector<char>buf(length);
            
            unsigned char *data = (unsigned char *)&buf[0];
            
            status = hid_get_feature_report(device,
                                            data,
                                            length);
            
            ob_set_b(returnValue, L"success", 0 == status);
            
            if(0 != status) {
                
                ob_set_a(returnValue, L"error", hid_error(device));
                
            }
            
            Param2.setBytes((const uint8_t *)data, (unsigned int)length);
            
        }
        
    }
    
    Param2.toParamAtIndex(pParams, 2);
    
    PA_ReturnObject(params, returnValue);
}

void hid_set_nonblocking(PA_PluginParameters params) {
    
    C_LONGINT Param1;
    C_LONGINT Param2;
    
    PA_ObjectRef returnValue = PA_CreateObject();
    
    ob_set_b(returnValue, L"success", false);
    
    if(is_libhidusb_ready) {
        
        PackagePtr pParams = (PackagePtr)params->fParameters;

        Param1.fromParamAtIndex(pParams, 1);
        Param2.fromParamAtIndex(pParams, 2);
        
        std::lock_guard<std::mutex> lock(globalMutex);
        
        hid_device *device = NULL;
        
        std::map<uint32_t, hid_device*>::iterator pos = __hid_devices.find(Param1.getIntValue());
        
        if(pos != __hid_devices.end()) {
            device = pos->second;
            
            int status = hid_set_nonblocking(device, Param2.getIntValue());
            
            ob_set_b(returnValue, L"success", 0 == status);
            
            if(0 != status) {
                
                ob_set_a(returnValue, L"error", hid_error(device));
                
            }
            
        }
        
    }
    
    PA_ReturnObject(params, returnValue);
}
